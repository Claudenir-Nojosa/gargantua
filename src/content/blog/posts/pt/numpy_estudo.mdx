---
title: "NumPy - Estudo Prático"
description: "Entendendo a importância dessa biblioteca de um modo 'hands-dirty'."
date: "2025-12-14"
author: "Claudenir Nojosa"
category: "NumPy"
tags: ["numpy", "python", "data-science"]
readTime: 18
featured: false
language: "pt"
coverImage: "https://miro.medium.com/v2/1*yQEkBd5NYvH0SRYgYOHTnA.png"
---
# Objetivo do Projeto

Este projeto tem como intuito aprender **mão na massa** o que é e como funciona a biblioteca **NumPy**, uma das ferramentas fundamentais do ecossistema de Data Science em Python.

---

## O que é NumPy?

**NumPy** (Numerical Python) é a biblioteca fundamental para computação científica em Python. Ela fornece suporte para arrays multidimensionais e matrizes, juntamente com uma vasta coleção de funções matemáticas de alto nível para operar nesses arrays.

### Por que usar NumPy?

Embora seja possível trabalhar com dados numéricos usando estruturas nativas do Python como `lists`, `sets` e `tuples`, o NumPy oferece vantagens significativas:

- **Performance Superior**: Operações em NumPy são até 100x mais rápidas que listas Python puras
- **Eficiência de Memória**: Arrays NumPy consomem menos memória que listas Python
- **Sintaxe Simplificada**: Operações vetorizadas eliminam a necessidade de loops explícitos
- **Recursos Matemáticos**: Ampla biblioteca de funções matemáticas, estatísticas e álgebra linear

### NumPy como Fundação do Ecossistema

NumPy é a base sobre a qual muitas outras bibliotecas científicas Python são construídas:

- **Pandas**: DataFrames são construídos sobre NumPy arrays
- **Scikit-learn**: Todos os algoritmos de machine learning usam NumPy
- **TensorFlow/PyTorch**: Frameworks de deep learning utilizam estruturas similares
- **Matplotlib/Seaborn**: Visualizações de dados processam NumPy arrays

Por isso, dominar NumPy é **essencial** para qualquer projeto de Data Science, Machine Learning ou Análise de Dados em Python.

---

### Instalação
```python
# Caso ainda não tenha o NumPy instalado
pip install numpy
```

### Importando a Biblioteca
```python
import numpy as np

# Verificando a versão instalada
print(f"NumPy versão: {np.__version__}")
```

### Começo do Estudo Prático
```python
arr = np.array([1, 2, 3])
print(f"Array: {arr}")
print(f"Tipo do objeto: {type(arr)}")
print(f"Tipo dos dados: {arr.dtype}")
print(f"Dimensões (shape): {arr.shape}")
print(f"Número de dimensões: {arr.ndim}")
```
```text
Array: [1 2 3]
Tipo do objeto: <class 'numpy.ndarray'>
Tipo dos dados: int32
Dimensões (shape): (3,)
Número de dimensões: 1
```

```python
# Importando um dataset de exemplo para trabalhar com NumPy
# Utilizaremos o dataset de vinhos do Scikit-Learn, que contém características químicas de diferentes tipos de vinho

from sklearn.datasets import load_wine

# load_wine() retorna um objeto Bunch (similar a um dicionário)
# Podemos acessar os dados tanto por chave ['data'] quanto por atributo .data
data_bunch = load_wine()

# Extraindo os dados numéricos do dataset
# Isso retorna um NumPy array com todas as características dos vinhos
wine_data_arr = data_bunch['data']

# Visualizando informações sobre o array
print(f"Tipo do objeto: {type(wine_data_arr)}")
print(f"Shape (dimensões): {wine_data_arr.shape}")
print(f"Total de elementos: {wine_data_arr.size}")
print(f"\nPrimeira amostra (índice 0):")
print(wine_data_arr[0])

# Entendendo o que cada dimensão representa:
# - Primeira dimensão (178): número de amostras de vinho
# - Segunda dimensão (13): número de características químicas por amostra
```
```text
Tipo do objeto: <class 'numpy.ndarray'>
Shape (dimensões): (178, 13)
Total de elementos: 2314

Primeira amostra (índice 0):
[1.423e+01 1.710e+00 2.430e+00 1.560e+01 1.270e+02 2.800e+00 3.060e+00
 2.800e-01 2.290e+00 5.640e+00 1.040e+00 3.920e+00 1.065e+03]
```
```python
# Utilizando 'shape' nós conseguimos identificar a quantidade de linhas e colunas do dataset
wine_data_arr.shape
```
```text
(178, 13)
```
```python
# Acessando os nomes das features (características) do dataset
# Cada coluna do array representa uma característica química diferente do vinho
feature_names = data_bunch['feature_names']

# Também podemos visualizar apenas o array de nomes
print(f"\nArray completo de features:")
print(feature_names)
```
```text
Array completo de features:
['alcohol', 'malic_acid', 'ash', 'alcalinity_of_ash', 'magnesium', 'total_phenols', 'flavanoids', 'nonflavanoid_phenols', 'proanthocyanins', 'color_intensity', 'hue', 'od280/od315_of_diluted_wines', 'proline']
```
```python
# Acessando colunas específicas do array
# Sintaxe: array[linhas, colunas]
# ':' significa "todas as linhas"
# '0' significa "coluna de índice 0"

# Extraindo a coluna 'alcohol' (primeira característica, índice 0)
alcohol_column = wine_data_arr[:, 0]

print(f"Feature selecionada: {feature_names[0]}")
print(f"Shape da coluna: {alcohol_column.shape}")
print(f"Primeiros 10 valores de {feature_names[0]}:")
print(alcohol_column[:10])

# Podemos também acessar outras colunas
# Exemplo: coluna 'malic_acid' (índice 1)
malic_acid_column = wine_data_arr[:, 1]
print(f"\nFeature selecionada: {feature_names[1]}")
print(f"Primeiros 10 valores de {feature_names[1]}:")
print(malic_acid_column[:10])
```
```text
Feature selecionada: alcohol
Shape da coluna: (178,)
Primeiros 10 valores de alcohol:
[14.23 13.2  13.16 14.37 13.24 14.2  14.39 14.06 14.83 13.86]

Feature selecionada: malic_acid
Primeiros 10 valores de malic_acid:
[1.71 1.78 2.36 1.95 2.59 1.76 1.87 2.15 1.64 1.35]
```
```python
# Exemplo de como acessar mais de uma coluna, nesse caso, 4 colunas
wine_data_arr[:, 0:4]
```
```text
(178, 4)
```
```python
# Exemplo de como acessar duas colunas específicas
wine_data_arr[:, (0, 2)]
```
```text
(178, 2)
```
```python
# Exemplo de como pegar as primeiras 10 linhas
wine_data_arr[:10, 0]
```
```text
array([14.23, 13.2 , 13.16, 14.37, 13.24, 14.2 , 14.39, 14.06, 14.83,
       13.86])
```
```python
# Exemplo de como pegar as linhas 10 até 20
wine_data_arr[10:20, 0]
```
```text
array([14.1 , 14.12, 13.75, 14.75, 14.38, 13.63, 14.3 , 13.83, 14.19,
       13.64])
```

# Operações Matemáticas

## Element-wise Operations

Uma das grandes vantagens do NumPy é a capacidade de realizar operações matemáticas em todos os elementos de um array simultaneamente, sem a necessidade de loops explícitos. Isso é chamado de **operação vetorizada** ou **element-wise operation**.

```python
# Relembrando nosso array simples
arr
```
```text
array([1, 2, 3])
```

```python
# Multiplicação element-wise: cada elemento é multiplicado por 20
arr * 20
```
```text
array([20, 40, 60])
```

```python
# Divisão element-wise: cada elemento é dividido por 20
arr / 20
```
```text
array([0.05, 0.1 , 0.15])
```

```python
# Outras operações element-wise possíveis:
print(f"Adição: {arr + 10}")
print(f"Subtração: {arr - 2}")
print(f"Potenciação: {arr ** 2}")
print(f"Raiz quadrada: {np.sqrt(arr)}")
```
```text
Adição: [11 12 13]
Subtração: [-1  0  1]
Potenciação: [1 4 9]
Raiz quadrada: [1.         1.41421356 1.73205081]
```

```python
# Extraindo a coluna 'alcohol' para análises estatísticas
alcohol = wine_data_arr[:, 0]
```

```python
# Média: valor médio de todos os elementos
mean_alcohol = np.mean(alcohol)
print(f"Média de álcool: {mean_alcohol:.2f}")
```
```text
Média de álcool: 13.00
```

```python
# Mínimo: menor valor encontrado no array
min_alcohol = np.min(alcohol)
print(f"Mínimo de álcool: {min_alcohol:.2f}")
```
```text
Mínimo de álcool: 11.03
```

```python
# Máximo: maior valor encontrado no array
max_alcohol = np.max(alcohol)
print(f"Máximo de álcool: {max_alcohol:.2f}")
```
```text
Máximo de álcool: 14.83
```
```python
# Desvio padrão (Standard Deviation): mede a dispersão dos dados em relação à média
# Quanto maior o desvio padrão, mais dispersos estão os valores
std_alcohol = np.std(alcohol)
print(f"Desvio padrão de álcool: {std_alcohol:.2f}")

# Outras funções estatísticas úteis:
print(f"\nMediana: {np.median(alcohol):.2f}")
print(f"Variância: {np.var(alcohol):.2f}")
print(f"Percentil 25: {np.percentile(alcohol, 25):.2f}")
print(f"Percentil 75: {np.percentile(alcohol, 75):.2f}")
```
```text
Desvio padrão de álcool: 0.81

Mediana: 13.05
Variância: 0.66
Percentil 25: 12.36
Percentil 75: 13.68
```

## Filtrando os dados

### Vamos procurar os dados de todos os vinhos em que o Álcool é inferior a 13%

```python
# Vamos usar um boolean mask (filtro)
alcohol_under_13_boolean_mask = alcohol < 13
```

```python
# Depois de criar o boolean mask, basta passar esse true/false array para os dados que serão filtrados, só mostrarão os True.
wine_data_arr[alcohol_under_13_boolean_mask]
```
```text
array([[1.293e+01, 3.800e+00, 2.650e+00, ..., 1.030e+00, 3.520e+00,
        7.700e+02],
       [1.285e+01, 1.600e+00, 2.520e+00, ..., 1.090e+00, 3.630e+00,
        1.015e+03],
       [1.237e+01, 9.400e-01, 1.360e+00, ..., 1.050e+00, 1.820e+00,
        5.200e+02],
       ...,
       [1.282e+01, 3.370e+00, 2.300e+00, ..., 7.200e-01, 1.750e+00,
        6.850e+02],
       [1.220e+01, 3.030e+00, 2.320e+00, ..., 6.600e-01, 1.830e+00,
        5.100e+02],
       [1.277e+01, 2.390e+00, 2.280e+00, ..., 5.700e-01, 1.630e+00,
        4.700e+02]])
```

### Agora vamos pegar somente os Vinhos em que tem álcool inferior a 13% e Magnésio superior a 120

```python
# Primeiro pegamos a coluna do magnésio e guardamos numa variável
magnesium = wine_data_arr[:, 4]
```

```python
# Criamos a boolean mask
magnesium_over_120_boolean_mask = magnesium > 120
```

```python
# Juntamos as boolean masks em uma variável só, a qual será passada para o nosso dataset
combined_mask = alcohol_under_13_boolean_mask & magnesium_over_120_boolean_mask
```

```python
# Colocamos o filtro no dataset, aqui peguei apenas a coluna 0 e 4 de fato
wine_data_arr[combined_mask][:, (0, 4)]
```
```text
array([[ 12.21, 151.  ],
       [ 12.99, 139.  ],
       [ 12.33, 136.  ],
       [ 12.47, 162.  ],
       [ 11.81, 134.  ],
       [ 12.86, 122.  ]])
```


```python
# Não precisamos colocar em variáveis, também dá certo filtrando diretamente no dataset
wine_data_arr[
    (alcohol < 13)
    & (magnesium > 120)
][:, (0, 4)]
```
```text
array([[ 12.21, 151.  ],
       [ 12.99, 139.  ],
       [ 12.33, 136.  ],
       [ 12.47, 162.  ],
       [ 11.81, 134.  ],
       [ 12.86, 122.  ]])
```

## Filtrando Dados com Boolean Masks

O NumPy permite filtrar dados de forma eficiente usando **boolean masks** (máscaras booleanas). Uma boolean mask é um array de valores True/False que indica quais elementos devem ser selecionados.

### Exemplo 1: Vinhos com álcool inferior a 13%

```python
# Criando uma boolean mask (filtro booleano)
# Isso cria um array de True/False onde True indica que a condição foi satisfeita
alcohol_under_13_boolean_mask = alcohol < 13

print(f"Shape da mask: {alcohol_under_13_boolean_mask.shape}")
print(
    f"Quantidade de vinhos com álcool < 13%: {np.sum(alcohol_under_13_boolean_mask)}")
print(f"\nPrimeiros 10 valores da mask:")
print(alcohol_under_13_boolean_mask[:10])
```
```text
Shape da mask: (178,)
Quantidade de vinhos com álcool < 13%: 86

Primeiros 10 valores da mask:
[False False False False False False False False False False]
```

```python
# Aplicando a boolean mask ao dataset
# Retorna apenas as linhas onde a mask é True
filtered_wines = wine_data_arr[alcohol_under_13_boolean_mask]

print(f"Dataset original: {wine_data_arr.shape}")
print(f"Dataset filtrado: {filtered_wines.shape}")
print(f"\nPrimeiras 5 amostras filtradas:")
print(filtered_wines[:5])
```
```text
Dataset original: (178, 13)
Dataset filtrado: (86, 13)

Primeiras 5 amostras filtradas:
[[1.293e+01 3.800e+00 2.650e+00 1.860e+01 1.020e+02 2.410e+00 2.410e+00
  2.500e-01 1.980e+00 4.500e+00 1.030e+00 3.520e+00 7.700e+02]
 [1.285e+01 1.600e+00 2.520e+00 1.780e+01 9.500e+01 2.480e+00 2.370e+00
  2.600e-01 1.460e+00 3.930e+00 1.090e+00 3.630e+00 1.015e+03]
 [1.237e+01 9.400e-01 1.360e+00 1.060e+01 8.800e+01 1.980e+00 5.700e-01
  2.800e-01 4.200e-01 1.950e+00 1.050e+00 1.820e+00 5.200e+02]
 [1.233e+01 1.100e+00 2.280e+00 1.600e+01 1.010e+02 2.050e+00 1.090e+00
  6.300e-01 4.100e-01 3.270e+00 1.250e+00 1.670e+00 6.800e+02]
 [1.264e+01 1.360e+00 2.020e+00 1.680e+01 1.000e+02 2.020e+00 1.410e+00
  5.300e-01 6.200e-01 5.750e+00 9.800e-01 1.590e+00 4.500e+02]]
```

### Exemplo 2: Filtros Combinados - Álcool < 13% E Magnésio > 120

```python
# Extraindo a coluna de magnésio (índice 4)
magnesium = wine_data_arr[:, 4]

print(f"Feature: {feature_names[4]}")
print(
    f"Valores de magnésio - min: {np.min(magnesium):.2f}, max: {np.max(magnesium):.2f}")
```
```text
Feature: magnesium
Valores de magnésio - min: 70.00, max: 162.00
```

```python
# Criando a segunda boolean mask
magnesium_over_120_boolean_mask = magnesium > 120

print(
    f"Quantidade de vinhos com magnésio > 120: {np.sum(magnesium_over_120_boolean_mask)}")
```
```text
Quantidade de vinhos com magnésio > 120: 13
```

```python
# Combinando múltiplas condições usando operadores lógicos
# & (AND): ambas condições devem ser True
# | (OR): pelo menos uma condição deve ser True
# ~ (NOT): inverte True/False

combined_mask = alcohol_under_13_boolean_mask & magnesium_over_120_boolean_mask

print(f"Vinhos que atendem AMBAS as condições: {np.sum(combined_mask)}")
```
```text
Vinhos que atendem AMBAS as condições: 6
```

```python
# Aplicando o filtro combinado e selecionando apenas as colunas de interesse
# [:, (0, 4)] seleciona todas as linhas e apenas as colunas 0 (alcohol) e 4 (magnesium)
filtered_result = wine_data_arr[combined_mask][:, (0, 4)]

print(f"Shape do resultado: {filtered_result.shape}")
print(f"\nResultado - Colunas: [{feature_names[0]}, {feature_names[4]}]")
print(filtered_result)
```
```text
Shape do resultado: (6, 2)

Resultado - Colunas: [alcohol, magnesium]
[[ 12.21 151.  ]
 [ 12.99 139.  ]
 [ 12.33 136.  ]
 [ 12.47 162.  ]
 [ 11.81 134.  ]
 [ 12.86 122.  ]]
```

```python
# Forma mais concisa: aplicando filtros diretamente sem variáveis intermediárias
# Importante: use parênteses em cada condição ao combinar com & ou |
direct_filter = wine_data_arr[
    (alcohol < 13)
    & (magnesium > 120)
][:, (0, 4)]

print(f"Resultado usando filtro direto:")
print(direct_filter)

# Verificando se os resultados são idênticos
print(
    f"\nResultados são iguais: {np.array_equal(filtered_result, direct_filter)}")
```
```text
Resultado usando filtro direto:
[[ 12.21 151.  ]
 [ 12.99 139.  ]
 [ 12.33 136.  ]
 [ 12.47 162.  ]
 [ 11.81 134.  ]
 [ 12.86 122.  ]]

Resultados são iguais: True
```

## np.where

### Categorizar os Vinhos baseado no seu nível de Álcool
- Se o álcool é menor que 12% será categorizado como Baixo teor de Álcool;
- Se o álcool é maior que  14% será categorizado como Alto teor de Álcool;
- Se for entre 12% e 14% será categorizado como Médio teor de Álcool.


```python
np.where(alcohol < 12, 'Low Alcohol', 'Other')
```
```text
array(['Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Low Alcohol', 'Low Alcohol',
       'Other', 'Low Alcohol', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Low Alcohol', 'Other', 'Other', 'Low Alcohol',
       'Low Alcohol', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Low Alcohol', 'Other', 'Low Alcohol', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Low Alcohol', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Low Alcohol', 'Low Alcohol', 'Other',
       'Low Alcohol', 'Low Alcohol', 'Other', 'Low Alcohol',
       'Low Alcohol', 'Other', 'Other', 'Other', 'Low Alcohol',
       'Low Alcohol', 'Other', 'Other', 'Low Alcohol', 'Other', 'Other',
       'Low Alcohol', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other', 'Other', 'Other', 'Other', 'Other',
       'Other', 'Other', 'Other'], dtype='<U11')
```
```python
np.where(alcohol < 12, 'low alcohol',
         np.where(alcohol > 14, 'high alcohol', 'Moderate Alcohol'))
```
```text
array(['high alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'high alcohol', 'Moderate Alcohol', 'high alcohol', 'high alcohol',
       'high alcohol', 'high alcohol', 'Moderate Alcohol', 'high alcohol',
       'high alcohol', 'Moderate Alcohol', 'high alcohol', 'high alcohol',
       'Moderate Alcohol', 'high alcohol', 'Moderate Alcohol',
       'high alcohol', 'Moderate Alcohol', 'high alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'high alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'high alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'high alcohol', 'high alcohol', 'Moderate Alcohol', 'high alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'high alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'low alcohol', 'low alcohol',
       'Moderate Alcohol', 'low alcohol', 'Moderate Alcohol',
...
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'high alcohol', 'Moderate Alcohol',
       'Moderate Alcohol', 'Moderate Alcohol', 'Moderate Alcohol',
       'high alcohol'], dtype='<U16')
```

# np.sort

```python
# Ordem Crescente
np.sort(alcohol)
```
```text
array([11.03, 11.41, 11.45, 11.46, 11.56, 11.61, 11.62, 11.64, 11.65,
       11.66, 11.76, 11.79, 11.81, 11.82, 11.82, 11.84, 11.84, 11.87,
       11.96, 12.  , 12.  , 12.  , 12.04, 12.07, 12.08, 12.08, 12.08,
       12.08, 12.08, 12.16, 12.17, 12.2 , 12.21, 12.22, 12.25, 12.25,
       12.25, 12.29, 12.29, 12.29, 12.29, 12.33, 12.33, 12.34, 12.36,
       12.37, 12.37, 12.37, 12.37, 12.37, 12.37, 12.42, 12.42, 12.42,
       12.43, 12.45, 12.47, 12.51, 12.51, 12.52, 12.53, 12.58, 12.6 ,
       12.6 , 12.64, 12.67, 12.69, 12.7 , 12.7 , 12.72, 12.72, 12.77,
       12.77, 12.79, 12.81, 12.82, 12.84, 12.85, 12.85, 12.86, 12.87,
       12.88, 12.93, 12.93, 12.96, 12.99, 13.03, 13.05, 13.05, 13.05,
       13.05, 13.05, 13.05, 13.07, 13.08, 13.11, 13.11, 13.16, 13.16,
       13.17, 13.17, 13.2 , 13.23, 13.24, 13.24, 13.27, 13.28, 13.29,
       13.3 , 13.32, 13.34, 13.36, 13.39, 13.4 , 13.4 , 13.41, 13.45,
       13.48, 13.48, 13.49, 13.49, 13.5 , 13.5 , 13.51, 13.52, 13.56,
       13.56, 13.58, 13.58, 13.62, 13.63, 13.64, 13.67, 13.68, 13.69,
       13.71, 13.71, 13.72, 13.73, 13.73, 13.74, 13.75, 13.76, 13.77,
       13.78, 13.82, 13.83, 13.83, 13.84, 13.86, 13.86, 13.87, 13.88,
       13.88, 13.9 , 13.94, 14.02, 14.06, 14.06, 14.1 , 14.1 , 14.12,
       14.13, 14.16, 14.19, 14.2 , 14.21, 14.22, 14.22, 14.23, 14.3 ,
       14.34, 14.37, 14.38, 14.38, 14.39, 14.75, 14.83])
```

```python
# Ordem Decrescente
np.sort(alcohol)[:: -1]
```
```text
array([14.83, 14.75, 14.39, 14.38, 14.38, 14.37, 14.34, 14.3 , 14.23,
       14.22, 14.22, 14.21, 14.2 , 14.19, 14.16, 14.13, 14.12, 14.1 ,
       14.1 , 14.06, 14.06, 14.02, 13.94, 13.9 , 13.88, 13.88, 13.87,
       13.86, 13.86, 13.84, 13.83, 13.83, 13.82, 13.78, 13.77, 13.76,
       13.75, 13.74, 13.73, 13.73, 13.72, 13.71, 13.71, 13.69, 13.68,
       13.67, 13.64, 13.63, 13.62, 13.58, 13.58, 13.56, 13.56, 13.52,
       13.51, 13.5 , 13.5 , 13.49, 13.49, 13.48, 13.48, 13.45, 13.41,
       13.4 , 13.4 , 13.39, 13.36, 13.34, 13.32, 13.3 , 13.29, 13.28,
       13.27, 13.24, 13.24, 13.23, 13.2 , 13.17, 13.17, 13.16, 13.16,
       13.11, 13.11, 13.08, 13.07, 13.05, 13.05, 13.05, 13.05, 13.05,
       13.05, 13.03, 12.99, 12.96, 12.93, 12.93, 12.88, 12.87, 12.86,
       12.85, 12.85, 12.84, 12.82, 12.81, 12.79, 12.77, 12.77, 12.72,
       12.72, 12.7 , 12.7 , 12.69, 12.67, 12.64, 12.6 , 12.6 , 12.58,
       12.53, 12.52, 12.51, 12.51, 12.47, 12.45, 12.43, 12.42, 12.42,
       12.42, 12.37, 12.37, 12.37, 12.37, 12.37, 12.37, 12.36, 12.34,
       12.33, 12.33, 12.29, 12.29, 12.29, 12.29, 12.25, 12.25, 12.25,
       12.22, 12.21, 12.2 , 12.17, 12.16, 12.08, 12.08, 12.08, 12.08,
       12.08, 12.07, 12.04, 12.  , 12.  , 12.  , 11.96, 11.87, 11.84,
       11.84, 11.82, 11.82, 11.81, 11.79, 11.76, 11.66, 11.65, 11.64,
       11.62, 11.61, 11.56, 11.46, 11.45, 11.41, 11.03])
```

### Sort em todo dataset, baseado em uma coluna

```python
# Aqui argsort retorna os índices das linhas, não o conteúdo
alcohol_sort_idxs = np.argsort(alcohol)[:: -1]
```

```python
wine_data_arr[alcohol_sort_idxs][:, :3]
```
```text
array([[14.83,  1.64,  2.17],
       [14.75,  1.73,  2.39],
       [14.39,  1.87,  2.45],
       [14.38,  1.87,  2.38],
       [14.38,  3.59,  2.28],
       [14.37,  1.95,  2.5 ],
       [14.34,  1.68,  2.7 ],
       [14.3 ,  1.92,  2.72],
       [14.23,  1.71,  2.43],
       [14.22,  3.99,  2.51],
       [14.22,  1.7 ,  2.3 ],
       [14.21,  4.04,  2.44],
       [14.2 ,  1.76,  2.45],
       [14.19,  1.59,  2.48],
       [14.16,  2.51,  2.48],
       [14.13,  4.1 ,  2.74],
       [14.12,  1.48,  2.32],
       [14.1 ,  2.16,  2.3 ],
       [14.1 ,  2.02,  2.4 ],
       [14.06,  2.15,  2.61],
       [14.06,  1.63,  2.28],
       [14.02,  1.68,  2.21],
       [13.94,  1.73,  2.27],
       [13.9 ,  1.68,  2.12],
       [13.88,  5.04,  2.23],
...
       [11.56,  2.05,  3.23],
       [11.46,  3.74,  1.82],
       [11.45,  2.4 ,  2.42],
       [11.41,  0.74,  2.5 ],
       [11.03,  1.51,  2.2 ]])
```

## np.where - Filtragem Condicional

A função `np.where()` permite criar categorizações e transformações condicionais nos dados. É especialmente útil para criar novas features ou categorizar valores numéricos.

### Exemplo: Categorizar vinhos baseado no teor de álcool

**Critérios de classificação:**
- Álcool < 12%: **Baixo teor de Álcool**
- Álcool > 14%: **Alto teor de Álcool**
- Entre 12% e 14%: **Médio teor de Álcool**

```python
# np.where() com condição simples (binária)
# Sintaxe: np.where(condição, valor_se_true, valor_se_false)

simple_categorization = np.where(alcohol < 12, 'Low Alcohol', 'Other')

print(f"Primeiras 20 categorizações:")
print(simple_categorization[:20])
print(f"\nDistribuição:")
unique, counts = np.unique(simple_categorization, return_counts=True)
for label, count in zip(unique, counts):
    print(f"  {label}: {count} vinhos")
```
```text
Primeiras 20 categorizações:
['Other' 'Other' 'Other' 'Other' 'Other' 'Other' 'Other' 'Other' 'Other'
 'Other' 'Other' 'Other' 'Other' 'Other' 'Other' 'Other' 'Other' 'Other'
 'Other' 'Other']

Distribuição:
  Low Alcohol: 19 vinhos
  Other: 159 vinhos
```

```python
# np.where() aninhado para múltiplas condições
# Permite criar categorizações mais complexas encadeando condições

alcohol_category = np.where(
    alcohol < 12, 'Low Alcohol',
    np.where(alcohol > 14, 'High Alcohol', 'Moderate Alcohol')
)

print(f"Primeiras 20 categorizações:")
print(alcohol_category[:20])

print(f"\nDistribuição final das categorias:")
unique, counts = np.unique(alcohol_category, return_counts=True)
for label, count in zip(unique, counts):
    print(f"  {label}: {count} vinhos ({count/len(alcohol)*100:.1f}%)")
```
```text
Primeiras 20 categorizações:
['High Alcohol' 'Moderate Alcohol' 'Moderate Alcohol' 'High Alcohol'
 'Moderate Alcohol' 'High Alcohol' 'High Alcohol' 'High Alcohol'
 'High Alcohol' 'Moderate Alcohol' 'High Alcohol' 'High Alcohol'
 'Moderate Alcohol' 'High Alcohol' 'High Alcohol' 'Moderate Alcohol'
 'High Alcohol' 'Moderate Alcohol' 'High Alcohol' 'Moderate Alcohol']

Distribuição final das categorias:
  High Alcohol: 22 vinhos (12.4%)
  Low Alcohol: 19 vinhos (10.7%)
  Moderate Alcohol: 137 vinhos (77.0%)
```

## np.sort - Ordenação de Arrays

A função `np.sort()` permite ordenar arrays de forma eficiente. Por padrão, ordena em ordem crescente.

```python
# Ordenação em ordem crescente (padrão)
sorted_alcohol = np.sort(alcohol)

print(f"10 menores valores de álcool:")
print(sorted_alcohol[:10])
print(f"\n10 maiores valores de álcool:")
print(sorted_alcohol[-10:])
```
```text
10 menores valores de álcool:
[11.03 11.41 11.45 11.46 11.56 11.61 11.62 11.64 11.65 11.66]

10 maiores valores de álcool:
[14.22 14.23 14.3  14.34 14.37 14.38 14.38 14.39 14.75 14.83]
```

```python
# Ordenação em ordem decrescente
# Usando slicing reverso [::−1] para inverter o array ordenado
sorted_alcohol_desc = np.sort(alcohol)[::-1]

print(f"Álcool em ordem decrescente (top 15):")
print(sorted_alcohol_desc[:15])
```
```text
Álcool em ordem decrescente (top 15):
[14.83 14.75 14.39 14.38 14.38 14.37 14.34 14.3  14.23 14.22 14.22 14.21
 14.2  14.19 14.16]
```

### Ordenar todo o dataset baseado em uma coluna específica

Para ordenar um dataset inteiro mantendo a correspondência entre linhas, usamos `np.argsort()`, que retorna os **índices** da ordenação ao invés dos valores ordenados.

```python
# np.argsort() retorna os índices que ordenariam o array
# Esses índices podem ser usados para reordenar outras arrays ou o dataset completo

alcohol_sort_idxs = np.argsort(alcohol)[::-1]  # Ordem decrescente

print(f"Primeiros 10 índices (vinhos com mais álcool):")
print(alcohol_sort_idxs[:10])
print(f"\nValores de álcool correspondentes:")
print(alcohol[alcohol_sort_idxs[:10]])
```
```text
Primeiros 10 índices (vinhos com mais álcool):
[  8  13   6  14  46   3 158  16   0  39]

Valores de álcool correspondentes:
[14.83 14.75 14.39 14.38 14.38 14.37 14.34 14.3  14.23 14.22]
```


```python
# Aplicando os índices ordenados ao dataset completo
# Isso reordena todas as linhas mantendo a integridade dos dados
# Selecionando apenas as 3 primeiras colunas para visualização

sorted_dataset = wine_data_arr[alcohol_sort_idxs][:, :3]

print(f"Shape do dataset ordenado: {sorted_dataset.shape}")
print(f"\nPrimeiras 3 features: {feature_names[:3]}")
print(f"\nTop 10 vinhos com maior teor alcoólico:")
print(sorted_dataset[:10])

# Verificando que a ordenação está correta
print(f"\nVerificação - Coluna de álcool está em ordem decrescente:")
print(f"Primeira amostra (álcool): {sorted_dataset[0, 0]:.2f}")
print(f"Última amostra (álcool): {sorted_dataset[-1, 0]:.2f}")
```
```text
Shape do dataset ordenado: (178, 3)

Primeiras 3 features: ['alcohol', 'malic_acid', 'ash']

Top 10 vinhos com maior teor alcoólico:
[[14.83  1.64  2.17]
 [14.75  1.73  2.39]
 [14.39  1.87  2.45]
 [14.38  1.87  2.38]
 [14.38  3.59  2.28]
 [14.37  1.95  2.5 ]
 [14.34  1.68  2.7 ]
 [14.3   1.92  2.72]
 [14.23  1.71  2.43]
 [14.22  3.99  2.51]]

Verificação - Coluna de álcool está em ordem decrescente:
Primeira amostra (álcool): 14.83
Última amostra (álcool): 11.03
```


## Integração NumPy com Pandas

Pandas DataFrames são construídos sobre NumPy arrays. É muito comum precisar extrair os dados NumPy subjacentes de um DataFrame para realizar operações específicas ou usar em bibliotecas que requerem arrays NumPy.


```python
# Criando um DataFrame Pandas a partir do array NumPy
import pandas as pd

df = pd.DataFrame(wine_data_arr, columns=feature_names)

print(f"Tipo do objeto: {type(df)}")
print(f"Shape do DataFrame: {df.shape}")
```
```text
Tipo do objeto: <class 'pandas.core.frame.DataFrame'>
Shape do DataFrame: (178, 13)
```
```python
# Visualizando as primeiras linhas do DataFrame
df.head()
```

| alcohol | malic_acid | ash | alcalinity_of_ash | magnesium | total_phenols | flavanoids | nonflavanoid_phenols | proanthocyanins | color_intensity | hue | od280/od315_of_diluted_wines | proline |
|---------|------------|-----|-------------------|-----------|---------------|------------|---------------------|-----------------|-----------------|-----|------------------------------|---------|
| 14.23   | 1.71       | 2.43| 15.6              | 127.0     | 2.80          | 3.06       | 0.28                | 2.29            | 5.64            | 1.04| 3.92                         | 1065.0  |
| 13.20   | 1.78       | 2.14| 11.2              | 100.0     | 2.65          | 2.76       | 0.26                | 1.28            | 4.38            | 1.05| 3.40                         | 1050.0  |
| 13.16   | 2.36       | 2.67| 18.6              | 101.0     | 2.80          | 3.24       | 0.30                | 2.81            | 5.68            | 1.03| 3.17                         | 1185.0  |
| 14.37   | 1.95       | 2.50| 16.8              | 113.0     | 3.85          | 3.49       | 0.24                | 2.18            | 7.80            | 0.86| 3.45                         | 1480.0  |
| 13.24   | 2.59       | 2.87| 21.0              | 118.0     | 2.80          | 2.69       | 0.39                | 1.82            | 4.32            | 1.04| 2.93                         | 735.0   |


```python
# Extraindo o NumPy array subjacente de todo o DataFrame
# O atributo .values retorna o array NumPy completo

numpy_array_from_df = df.values

print(f"Tipo do objeto: {type(numpy_array_from_df)}")
print(f"Shape: {numpy_array_from_df.shape}")
print(f"Dtype: {numpy_array_from_df.dtype}")
print(f"\nPrimeiras 3 linhas:")
print(numpy_array_from_df[:3])
```
```text
Tipo do objeto: <class 'numpy.ndarray'>
Shape: (178, 13)
Dtype: float64

Primeiras 3 linhas:
[[1.423e+01 1.710e+00 2.430e+00 1.560e+01 1.270e+02 2.800e+00 3.060e+00
  2.800e-01 2.290e+00 5.640e+00 1.040e+00 3.920e+00 1.065e+03]
 [1.320e+01 1.780e+00 2.140e+00 1.120e+01 1.000e+02 2.650e+00 2.760e+00
  2.600e-01 1.280e+00 4.380e+00 1.050e+00 3.400e+00 1.050e+03]
 [1.316e+01 2.360e+00 2.670e+00 1.860e+01 1.010e+02 2.800e+00 3.240e+00
  3.000e-01 2.810e+00 5.680e+00 1.030e+00 3.170e+00 1.185e+03]]
```
```python
# Extraindo o NumPy array de uma coluna específica
# Isso retorna um array 1D com os valores daquela coluna

alcohol_from_df = df["alcohol"].values

print(f"Tipo do objeto: {type(alcohol_from_df)}")
print(f"Shape: {alcohol_from_df.shape}")
print(f"Primeiros 10 valores:")
print(alcohol_from_df[:10])
```
```text
Tipo do objeto: <class 'numpy.ndarray'>
Shape: (178,)
Primeiros 10 valores:
[14.23 13.2  13.16 14.37 13.24 14.2  14.39 14.06 14.83 13.86]
```

## Características dos Arrays NumPy

### Arrays Homogêneos
NumPy arrays são **homogêneos**, ou seja, todos os elementos devem ser do mesmo tipo de dado. Se você misturar tipos, o NumPy fará conversão automática para um tipo comum.

```python
# Exemplo: misturando integers e strings
# NumPy converte tudo para string (tipo mais genérico que preserva todos os valores)

mixed_array = np.array([1, 2, 'a'])

print(f"Array: {mixed_array}")
print(f"Dtype: {mixed_array.dtype}")
print(f"Todos os elementos são strings agora: {type(mixed_array[0])}")
```
```text
Array: ['1' '2' 'a']
Dtype: <U11
Todos os elementos são strings agora: <class 'numpy.str_'>
```

## Criando Sequences de Números

NumPy oferece funções eficientes para gerar sequences numéricas.

```python
# np.arange(): cria sequences de números com step definido
# Sintaxe: np.arange(início, fim, step)
# Nota: o valor final NÃO é incluído

range_integers = np.arange(1, 100, 3)

print(f"np.arange(1, 100, 3):")
print(f"Shape: {range_integers.shape}")
print(f"Primeiros 10 valores: {range_integers[:10]}")
print(f"Últimos 10 valores: {range_integers[-10:]}")
```
```text
np.arange(1, 100, 3):
Shape: (33,)
Primeiros 10 valores: [ 1  4  7 10 13 16 19 22 25 28]
Últimos 10 valores: [70 73 76 79 82 85 88 91 94 97]
```

```python
# np.linspace(): cria sequences com número específico de pontos igualmente espaçados
# Sintaxe: np.linspace(início, fim, quantidade_de_pontos)
# Nota: o valor final É incluído

range_floats = np.linspace(0, 1, 100)

print(f"np.linspace(0, 1, 100):")
print(f"Shape: {range_floats.shape}")
print(f"Primeiros 10 valores: {range_floats[:10]}")
print(f"Últimos 10 valores: {range_floats[-10:]}")
print(f"Espaçamento entre pontos: {range_floats[1] - range_floats[0]:.6f}")
```
```text
np.linspace(0, 1, 100):
Shape: (100,)
Primeiros 10 valores: [0.         0.01010101 0.02020202 0.03030303 0.04040404 0.05050505
 0.06060606 0.07070707 0.08080808 0.09090909]
Últimos 10 valores: [0.90909091 0.91919192 0.92929293 0.93939394 0.94949495 0.95959596
 0.96969697 0.97979798 0.98989899 1.        ]
Espaçamento entre pontos: 0.010101
```

## Reshape - Reorganizando Dimensões de Arrays

O `reshape` permite reorganizar os elementos de um array em uma nova estrutura dimensional, desde que o número total de elementos permaneça o mesmo.

### Exemplo prático: Visualizando dígitos escritos à mão

```python
# Carregando o dataset de dígitos do Scikit-Learn
# Cada dígito é representado como um array de 64 pixels (8x8 achatado)

from sklearn.datasets import load_digits

data_bunch_digits = load_digits()
digits_data = data_bunch_digits['data']

print(f"Shape do dataset: {digits_data.shape}")
print(f"Cada imagem tem {digits_data.shape[1]} pixels")
print(f"Total de imagens: {digits_data.shape[0]}")
```
```text
Shape do dataset: (1797, 64)
Cada imagem tem 64 pixels
Total de imagens: 1797
```

```python
# Verificando a forma original dos dados
print(f"Shape original: {digits_data.shape}")
print(f"Primeira imagem (array achatado):")
print(digits_data[0])
```
```text
Shape original: (1797, 64)
Primeira imagem (array achatado):
[ 0.  0.  5. 13.  9.  1.  0.  0.  0.  0. 13. 15. 10. 15.  5.  0.  0.  3.
 15.  2.  0. 11.  8.  0.  0.  4. 12.  0.  0.  8.  8.  0.  0.  5.  8.  0.
  0.  9.  8.  0.  0.  4. 11.  0.  1. 12.  7.  0.  0.  2. 14.  5. 10. 12.
  0.  0.  0.  0.  6. 13. 10.  0.  0.  0.]
```

```python
# Reorganizando de 1D (64 pixels) para 2D (8x8)
# Isso permite visualizar a imagem como uma matriz

reshaped_digit = np.reshape(digits_data[0], (8, 8))

print(f"Shape após reshape: {reshaped_digit.shape}")
print(f"\nImagem como matriz 8x8:")
print(reshaped_digit)
```
```text
Shape após reshape: (8, 8)

Imagem como matriz 8x8:
[[ 0.  0.  5. 13.  9.  1.  0.  0.]
 [ 0.  0. 13. 15. 10. 15.  5.  0.]
 [ 0.  3. 15.  2.  0. 11.  8.  0.]
 [ 0.  4. 12.  0.  0.  8.  8.  0.]
 [ 0.  5.  8.  0.  0.  9.  8.  0.]
 [ 0.  4. 11.  0.  1. 12.  7.  0.]
 [ 0.  2. 14.  5. 10. 12.  0.  0.]
 [ 0.  0.  6. 13. 10.  0.  0.  0.]]
```

```python
# Visualizando a imagem usando matplotlib
import matplotlib.pyplot as plt

plt.figure(figsize=(6, 6))
plt.imshow(reshaped_digit, cmap='gray')
plt.title(f'Dígito: {data_bunch_digits["target"][0]}')
plt.colorbar(label='Intensidade do pixel')
plt.grid(False)
plt.show()

print(f"Este é o dígito: {data_bunch_digits['target'][0]}")
```
![Output Números](https://raw.githubusercontent.com/Claudenir-Nojosa/servidor_estaticos/refs/heads/main/output%201.png)
```text
Este é o dígito: 0
```
```python
# Visualizando múltiplos dígitos
fig, axes = plt.subplots(2, 5, figsize=(12, 6))
axes = axes.ravel()

for i in range(10):
    axes[i].imshow(np.reshape(digits_data[i], (8, 8)), cmap='gray')
    axes[i].set_title(f'Dígito: {data_bunch_digits["target"][i]}')
    axes[i].axis('off')

plt.tight_layout()
plt.show()
```
![Output Números](https://raw.githubusercontent.com/Claudenir-Nojosa/servidor_estaticos/refs/heads/main/output%202.png)

## Conclusão

Este notebook apresentou os fundamentos essenciais do **NumPy**, a biblioteca base para computação numérica e científica em Python.

### Principais Conceitos Aprendidos

**1. Estrutura de Dados Fundamental**
- NumPy arrays (ndarray) são estruturas n-dimensionais homogêneas
- Oferecem performance superior e eficiência de memória comparado a listas Python
- São a base para bibliotecas como Pandas, Scikit-Learn e frameworks de deep learning

**2. Operações Vetorizadas**
- Operações element-wise eliminam a necessidade de loops explícitos
- Funções matemáticas e estatísticas integradas (mean, std, min, max, etc.)
- Ganhos significativos de performance em operações sobre grandes volumes de dados

**3. Indexação e Filtragem Avançada**
- Slicing multidimensional para acessar linhas e colunas específicas
- Boolean masks para filtragem condicional eficiente
- Combinação de múltiplas condições usando operadores lógicos (&, |, ~)

**4. Transformação de Dados**
- `np.where()` para categorizações e transformações condicionais
- `np.sort()` e `np.argsort()` para ordenação de arrays e datasets
- `np.reshape()` para reorganização dimensional de dados

**5. Integração com o Ecossistema**
- Conversão bidirecional entre Pandas DataFrames e NumPy arrays
- Aplicação prática com datasets reais (vinhos, dígitos manuscritos)
- Visualização de dados usando Matplotlib

### Importância do NumPy em Data Science

O domínio de NumPy é **fundamental** para qualquer profissional de dados, pois:

- É a fundação do ecossistema científico Python
- Permite manipulação eficiente de grandes volumes de dados
- Fornece as operações matemáticas necessárias para análises estatísticas
- É requisito para trabalhar com machine learning e deep learning
- Integra-se perfeitamente com outras bibliotecas especializadas
